<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<title>Shared Canvas</title>
<style>
  html, body {
    height:100%; margin:0;
    background: linear-gradient(180deg,#071022,#07101a);
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    font-family:system-ui; color:#fff;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
  }
  .controls { display:flex; gap:10px; align-items:center; margin-bottom:10px; flex-wrap:wrap; justify-content:center; }
  .btn { background:linear-gradient(90deg,#0ea5a4,#7c3aed); color:white; padding:8px 12px; border-radius:8px; border:0; cursor:pointer; font-weight:600; }
  .panel { width:95%; height:60%; border-radius:12px; overflow:hidden; position:relative; box-shadow:0 18px 50px rgba(2,6,23,0.7); }
  canvas { display:block; width:100%; height:100%; background:#ffffff; cursor:crosshair; touch-action: none; }
  .link { margin-top:12px; color:#06b6d4; text-decoration:none; font-weight:bold; word-break: break-word; text-align:center; }
  .active-count { margin-bottom:8px; color:#06b6d4; font-weight:bold; }
</style>
</head>
<body>

<div class="active-count">Active Users: <span id="userCount">0</span></div>

<div class="controls">
  <label>Color <input id="color" type="color" value="#06b6d4" style="margin-left:8px"></label>
  <label style="margin-left:8px">Size <input id="size" type="range" min="1" max="80" value="6" style="margin-left:8px"></label>
  <button id="eraser" class="btn">Eraser</button>
  <button id="clear" class="btn">Clear</button>
  <button id="undo" class="btn">Undo</button>
  <button id="fill" class="btn">Fill</button>
</div>

<div class="panel" id="panel">
  <canvas id="canvas"></canvas>
</div>

<a class="link" href="https://mtch3000.github.io/draw/" target="_blank">https://mtch3000.github.io/draw/</a>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import { getDatabase, ref, onChildAdded, push, remove, onValue, onDisconnect, set } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";

// Firebase config
const firebaseConfig = {
    apiKey: "AIzaSyBFc597khPRThMIGF4BRkqA7VxnNEM0zFk",
    authDomain: "shared-drawing-canvas.firebaseapp.com",
    databaseURL: "https://shared-drawing-canvas-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "shared-drawing-canvas",
    storageBucket: "shared-drawing-canvas.firebasestorage.app",
    messagingSenderId: "379615731075",
    appId: "1:379615731075:web:113fea60f358360975aab6"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const drawRef = ref(db, "drawings");
const usersRef = ref(db, "activeUsers");

const canvas = document.getElementById('canvas');
const panel = document.getElementById('panel');
const ctx = canvas.getContext('2d');
const colorInput = document.getElementById('color');
const sizeInput = document.getElementById('size');
const clearBtn = document.getElementById('clear');
const eraserBtn = document.getElementById('eraser');
const undoBtn = document.getElementById('undo');
const fillBtn = document.getElementById('fill');
const userCountEl = document.getElementById('userCount');

let drawing = false, last = {x:0,y:0}, isEraser = false;
let strokeKeys = []; // store stroke keys for undo

// Responsive canvas
function resize(){
  const ratio = window.devicePixelRatio || 1;
  const width = window.innerWidth * 0.95;
  const height = window.innerHeight * 0.6;
  canvas.style.width = width + "px";
  canvas.style.height = height + "px";
  canvas.width = width * ratio;
  canvas.height = height * ratio;
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(ratio, ratio);
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.fillStyle = "#fff";
  ctx.fillRect(0,0,canvas.width,canvas.height);
}
resize();
window.addEventListener('resize', resize);

// pointer helper
function getPos(e){
  const rect = canvas.getBoundingClientRect();
  const t = e.touches ? e.touches[0] : e;
  return {x: t.clientX - rect.left, y: t.clientY - rect.top};
}

// draw line
function drawLine(data){
  ctx.lineWidth = data.size;
  ctx.strokeStyle = data.erase ? "rgba(0,0,0,1)" : data.color;
  ctx.globalCompositeOperation = data.erase ? "destination-out" : "source-over";
  ctx.beginPath();
  ctx.moveTo(data.from.x, data.from.y);
  ctx.lineTo(data.to.x, data.to.y);
  ctx.stroke();
}

// redraw all strokes
function redrawAll(allStrokes){
  ctx.fillStyle = "#fff";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  allStrokes.forEach(data => drawLine(data));
}

// pointer events
function pointerDown(e){ e.preventDefault(); drawing = true; last = getPos(e); }
function pointerMove(e){
  if(!drawing) return;
  const pos = getPos(e);
  const line = {from:last, to:pos, color:colorInput.value, size:+sizeInput.value, erase:isEraser};
  drawLine(line);
  const newRef = push(drawRef);
  set(newRef, line);
  strokeKeys.push(newRef.key); // store key for undo
  last = pos;
}
function pointerUp(){ drawing = false; }

canvas.addEventListener("mousedown", pointerDown);
canvas.addEventListener("mousemove", pointerMove);
window.addEventListener("mouseup", pointerUp);
canvas.addEventListener("touchstart", pointerDown, {passive:false});
canvas.addEventListener("touchmove", pointerMove, {passive:false});
window.addEventListener("touchend", pointerUp);

// prevent scroll while drawing
document.body.addEventListener('touchmove', e => { if(drawing) e.preventDefault(); }, {passive:false});

// eraser toggle
eraserBtn.addEventListener("click", ()=>{
  isEraser = !isEraser;
  eraserBtn.textContent = isEraser ? "Draw" : "Eraser";
});

// clear button
clearBtn.addEventListener("click", ()=>{
  remove(drawRef);
  strokeKeys = [];
  ctx.fillStyle = "#fff";
  ctx.fillRect(0,0,canvas.width,canvas.height);
});

// undo button
undoBtn.addEventListener("click", ()=>{
  if(strokeKeys.length === 0) return;
  const lastKey = strokeKeys.pop();
  remove(ref(db, `drawings/${lastKey}`));
});

// fill button
fillBtn.addEventListener("click", ()=>{
  const fillColor = colorInput.value;
  ctx.fillStyle = fillColor;
  ctx.fillRect(0,0,canvas.width,canvas.height);
  // Save as a single stroke in DB so everyone sees
  const fillRef = push(drawRef);
  set(fillRef, {from:{x:0,y:0}, to:{x:canvas.width, y:canvas.height}, color:fillColor, size:canvas.width, erase:false, fill:true});
});

// redraw strokes from Firebase
onChildAdded(drawRef, snapshot => {
  const data = snapshot.val();
  if(data.fill){
    ctx.fillStyle = data.color;
    ctx.fillRect(0,0,canvas.width,canvas.height);
  } else {
    drawLine(data);
  }
});

// clear canvas if DB cleared
onValue(drawRef, snapshot => {
  if(!snapshot.exists()){
    ctx.fillStyle = "#fff";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    strokeKeys = [];
  }
});

// ======= Active users tracking =======
const userId = 'user_' + Date.now() + '_' + Math.floor(Math.random()*1000);
const userRef = ref(db, `activeUsers/${userId}`);
set(userRef, true);
onDisconnect(userRef).remove();
onValue(usersRef, snapshot => {
  const count = snapshot.exists() ? Object.keys(snapshot.val()).length : 0;
  userCountEl.textContent = count;
});
</script>
</body>
</html>
